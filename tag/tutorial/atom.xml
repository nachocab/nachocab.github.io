<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
   
    <title>reasoniamhere.com - Tag: tutorial</title>
   
   <link>http://reasoniamhere.com</link>
   <description>I am a Spanish-born bioinformatics PhD student living in Boston</description>
   <language>en-us</language>
   <managingEditor>Nacho Caballero</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />

    
      <item>
        <title>Master Your Z Shell with These Outrageously Useful Tips</title>
        <link>http://reasoniamhere.com/2014/01/11/outrageously-useful-tips-to-master-your-z-shell</link>
        <author>Nacho Caballero</author>
        <pubDate>2014-01-11T00:00:00-05:00</pubDate>
        <guid>http://reasoniamhere.com/2014/01/11/outrageously-useful-tips-to-master-your-z-shell</guid>
        <description><![CDATA[
           <p>If you had previously installed Zsh but never got around to exploring all of its magic features, this post is for you.</p>

<p>If you never thought of using a different shell than the one that came by default when you got your computer, I recommend you go out and check the Z shell. Here are some <a href="http://blog.coolaj86.com/articles/zsh-is-to-bash-as-vim-is-to-vi.html">Linux</a> <a href="http://linuxg.net/how-to-install-zsh-shell-how-to-set-it-as-a-default-login-shell/">guides</a> that explain how to install it and set it as your default shell. You probably have Zsh installed you are on a Mac, but there&rsquo;s nothing like the warm fuzzy feeling of running the latest version (here&rsquo;s <a href="http://zanshin.net/2013/09/03/how-to-use-homebrew-zsh-instead-of-max-os-x-default/">a way to upgrade</a> using Homebrew).</p>

<p>While you&rsquo;re at it, you should also get <strong>oh-my-zsh</strong>, a framework that makes Zsh easier to configure. It&rsquo;s pretty easy to install, just run this:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh <span class="p">|</span> sh

<span class="nb">echo</span> <span class="nv">$0</span>
<span class="c"># if you don&#39;t see /bin/zsh you might need</span>
<span class="c"># to open up a new window, or manually run: zsh</span>
</code></pre></div>
<p><hr></p>

<p>The Zsh manual is a daunting beast. Just the <a href="http://zsh.sourceforge.net/Doc/Release/Expansion.html">chapter on expansions</a> has 32 subsections. Forget about memorizing this madness in one sitting. Instead, we&rsquo;ll focus on understanding a few useful concepts, and referencing the manual for additional help.</p>

<p>The three main sections of this post are <strong>file picking</strong>, <strong>variable transformations</strong>, and <strong>magic tabbing</strong>. If you&rsquo;re pressed for time, read the beginning of each one, and come back later to soak up the details (make sure you stick around for the bonus tips at the end).</p>

<!--excerpt-->

<h2>You only learn by doing</h2>

<p>Reading this post will only take you 10% of the way into Zsh paradise; to really grok what it&rsquo;s all about, you need to run the commands yourself. I&rsquo;m giving you everything you need to create the file structure that we&rsquo;ll be using for the entire post. Simply copy and paste this into your Zsh window:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># run me to get the party started</span>

<span class="c"># create the folder structure</span>
mkdir -p zsh_demo/<span class="o">{</span>data,calculations<span class="o">}</span>/africa/<span class="o">{</span>kenya,malawi<span class="o">}</span>/ zsh_demo/<span class="o">{</span>data,calculations<span class="o">}</span>/europe/<span class="o">{</span>malta,poland<span class="o">}</span>/ zsh_demo/<span class="o">{</span>data,calculations<span class="o">}</span>/asia/<span class="o">{</span>nepal,laos<span class="o">}</span>/

<span class="c"># create dummy files inside the data folder</span>
<span class="k">for</span> country_folder in zsh_demo/data/*/*<span class="p">;</span> <span class="k">do</span>
    dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span><span class="s2">&quot;${country_folder}/population.txt&quot;</span> <span class="nv">bs</span><span class="o">=</span><span class="m">1024</span> <span class="nv">count</span><span class="o">=</span>1
    dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span><span class="s2">&quot;${country_folder}/income.txt&quot;</span> <span class="nv">bs</span><span class="o">=</span><span class="m">2048</span> <span class="nv">count</span><span class="o">=</span>1
    dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span><span class="s2">&quot;${country_folder}/literacy.txt&quot;</span> <span class="nv">bs</span><span class="o">=</span><span class="m">4096</span> <span class="nv">count</span><span class="o">=</span>1
    <span class="c"># we say these are dummy files because they don&#39;t have any content,</span>
    <span class="c"># but we are making them occupy disk space</span>
<span class="k">done</span>

<span class="c"># create dummy files inside the calculations folder</span>
<span class="k">for</span> country_folder in zsh_demo/calculations/*/*<span class="p">;</span> <span class="k">do</span>
    touch <span class="s2">&quot;${country_folder}/population_by_province.txt&quot;</span>    <span class="c"># this file is empty</span>
    dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span><span class="s2">&quot;${country_folder}/median_income.txt&quot;</span> <span class="nv">bs</span><span class="o">=</span><span class="m">2048</span> <span class="nv">count</span><span class="o">=</span>1
    dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span><span class="s2">&quot;${country_folder}/literacy_index.txt&quot;</span> <span class="nv">bs</span><span class="o">=</span><span class="m">4096</span> <span class="nv">count</span><span class="o">=</span>1
<span class="k">done</span>

<span class="c"># because all the files are nested within the zsh_demo folder you will</span>
<span class="c"># be able to easily delete them by running:</span>
<span class="c"># rm -r zsh_demo</span>
</code></pre></div>
<p>Your file structure should look like this <code>zsh_demo/{data,calculations}/{continent}{/country}/{file}.txt</code>:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">zsh_demo
├── data
│   ├── africa
│   │   ├── kenya
│   │   │   ├── literacy.txt
│   │   │   ├── income.txt
│   │   │   └── population.txt
│   │   └── ...
│   ├── asia
│   │   ├── ...
│   └── europe
│       ├── ...
└── data
    ├── africa
    │   ├── kenya
    │   │   ├── literacy_index.txt
    │   │   ├── median_income.txt
    │   │   └── population_by_province.txt
    │   └── ...
    ├── ...
</code></pre></div>
<p>Although you might not initially care about continents and countries, try to relate the examples we&rsquo;ll be looking at with the type of file structure you usually work with.</p>

<h2>1. File picking</h2>

<p>Warning for purists: some of the features I talk about are not exclusive to Zsh, but I have explain them anyway before we can move on to sexier commands.</p>

<p>First off, <strong>globbing</strong>! A glob is a short expression that lets you select a bunch of files. 99% of the time, there&rsquo;s an asterisk involved.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># run me please</span>

ls zsh_demo/**/*.txt <span class="c"># &lt;= this is a glob</span>
</code></pre></div>
<p>Globs get replaced by the names of the files that match the glob expression. For example, the glob  above lists every text file located anywhere in the <code>zsh_demo</code> folder. Let&rsquo;s break it down to see what each part is doing:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># list every file directly below the zsh_demo folder</span>
ls zsh_demo

<span class="c"># list every file in the folders directly below the zsh_demo folder</span>
ls zsh_demo/*

<span class="c"># list every file in every folder two levels below the zsh_demo folder</span>
ls zsh_demo/*/*

<span class="c"># list every file anywhere below the zsh_demo folder</span>
ls zsh_demo/**/*

<span class="c"># list every file that ends in .txt in every folder at any level below the zsh_demo folder</span>
ls zsh_demo/**/*.txt
</code></pre></div>
<p>We already used a glob when we specified the location of each file:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="k">for</span> country_folder in zsh_demo/data/*/*<span class="p">;</span> <span class="k">do</span>
    <span class="c"># create data files for each country</span>
<span class="k">done</span>
</code></pre></div>
<p>This loop runs six times. See for yourself:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">print -l zsh_demo/data/*/*
<span class="c"># zsh_demo/africa/kenya</span>
<span class="c"># zsh_demo/africa/malawi</span>
<span class="c"># zsh_demo/asia/laos</span>
<span class="c"># zsh_demo/asia/nepal</span>
<span class="c"># zsh_demo/europe/malta</span>
<span class="c"># zsh_demo/europe/poland</span>

<span class="c"># you could use echo instead of print -l, but the folders would be</span>
<span class="c"># separated by spaces instead of newlines</span>
</code></pre></div>
<h3>Glob operators</h3>

<p>So, what else can you stick inside a glob besides asterisks? Glance at section <a href="http://zsh.sourceforge.net/Doc/Release/Expansion.html#Filename-Generation">14.8.1 of the manual</a> if you want to know all the options. Here are the ones that I find most useful:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># list text files that end in a number from 1 to 10</span>
ls -l zsh_demo/**/*&lt;1-10&gt;.txt

<span class="c"># list text files that start with the letter a</span>
ls -l zsh_demo/**/<span class="o">[</span>a<span class="o">]</span>*.txt

<span class="c"># list text files that start with either ab or bc</span>
ls -l zsh_demo/**/<span class="o">(</span>ab<span class="p">|</span>bc<span class="o">)</span>*.txt

<span class="c"># list text files that don&#39;t start with a lower or uppercase c</span>
ls -l zsh_demo/**/<span class="o">[</span>^cC<span class="o">]</span>*.txt
</code></pre></div>
<h3>Glob qualifiers</h3>

<p>Now that we got the basic stuff out of the way, let&rsquo;s dive a little deeper. We previously mentioned this glob: <code>zsh_demo/**/*</code>, which lists every file anywhere below the <code>zsh_demo</code> folder. But, what if we only want to list folders and not regular files, or vice versa? What if we only want to list files bigger than 3 KB? Or maybe, just the last modified file? You can do all that in Zsh using <strong>glob qualifiers</strong>:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># show only directories</span>
print -l zsh_demo/**/*<span class="o">(</span>/<span class="o">)</span>

<span class="c"># show only regular files</span>
print -l zsh_demo/**/*<span class="o">(</span>.<span class="o">)</span>

<span class="c"># show empty files</span>
ls -l zsh_demo/**/*<span class="o">(</span>L0<span class="o">)</span>

<span class="c"># show files greater than 3 KB</span>
ls -l zsh_demo/**/*<span class="o">(</span>Lk+3<span class="o">)</span>

<span class="c"># show files modified in the last hour</span>
print -l zsh_demo/**/*<span class="o">(</span>mh-1<span class="o">)</span>

<span class="c"># sort files from most to least recently modified and show the last 3</span>
ls -l zsh_demo/**/*<span class="o">(</span>om<span class="o">[</span>1,3<span class="o">])</span>
</code></pre></div>
<p>Glob qualifiers are surrounded in parentheses <code>()</code>, and appear at the end of a glob to make it more stringent. Globs filter files by their name, and glob qualifiers filter by any other attribute (file type, size, modification date). They can be a bit confusing if you don&rsquo;t know the syntax. Consider this glob qualifier:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">ls -l zsh_demo/**/*<span class="o">(</span>.Lm-2mh-1om<span class="o">[</span>1,3<span class="o">])</span>
<span class="c"># you won&#39;t typically write at this level of obfuscation</span>

ls -l zsh_demo/**/*<span class="o">(</span>. Lm-2 mh-1 om <span class="o">[</span>1,3<span class="o">])</span>
<span class="c"># this is more parseable, but unfortunately Zsh doesn&#39;t allow spaces</span>
<span class="c"># between qualifiers, so you&#39;ll get an error</span>
</code></pre></div>
<p>You need to be familiar with the individual options to make sense of this madness. Five different things are going on at the same time:</p>

<ol>
<li>The <code>.</code> tells the glob to only show <strong>regular files</strong> (no directories, symbolic links, or other types of files).</li>
<li>The <code>Lm-2</code> tells the glob to show files smaller than 2 MB.

<ul>
<li>Use <code>-</code> for smaller, and <code>+</code> for greater; don&rsquo;t use anything if you want to specify the exact size (<code>Lm2</code>).</li>
<li>Use <code>m</code> for megabytes, <code>k</code> for kilobytes, or nothing for just bytes (notice that these letters must appear <strong>before</strong> the sign).</li>
</ul></li>
<li>The <code>mh-1</code> tells the glob to show files modified in the last hour

<ul>
<li>Use <code>-</code> if you want files modified within the last X units of time, and <code>+</code> for files modified more than X units of time ago.</li>
<li>Use <code>M</code> for Months, <code>w</code> for weeks, <code>h</code> for hours, <code>m</code> for minutes, and <code>s</code> for seconds (notice that these leters must appear <strong>before</strong> the sign).</li>
</ul></li>
<li>The <code>om</code> tells the glob to sort the remaining files by their modification date.

<ul>
<li>A lowercase <code>o</code> sorts by most recent first, to use the reverse order, make it uppercase <code>O</code>.</li>
<li>Use <code>m</code> to sort by modification date, and <code>L</code> to sort by size (<code>oL</code>).</li>
</ul></li>
<li>The <code>[1,3]</code> tells the glob to show the first 3 files (since we just sorted the files, these will be the most recently modified ones).

<ul>
<li>You can also show a single file (for example, the second one <code>[2]</code>)</li>
</ul></li>
</ol>

<p>Syntax is a trade-off between terseness and obscurity. To people that are familiar with the Zsh jargon, the ability to combine five different filters by only typing a few characters is an awesome feature; to everybody else, it&rsquo;s incomprehensible mumbo-jumbo. Fortunately, useful shortcuts get used more often, and they become easier to remember.</p>

<p>Head over to <a href="http://zsh.sourceforge.net/Doc/Release/Expansion.html#Filename-Generation">section 14.8.7 of the manual</a> if you&rsquo;d like to be showered in details.</p>

<p><strong>Pro Tip</strong></p>

<p>Here&rsquo;s a cool tip for all you advanced devils (feel free to skip to section 2 if you&rsquo;ve had enough file pickin&rsquo; for a day). How can we select folders that don&rsquo;t contain a given file? In the manual you&rsquo;ll find information about a qualifier called <code>estring</code>, which runs the code specified by the string, and only keeps the file names that return <em>true</em>. For example:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># show every continent that doesn&#39;t contain a country named malta</span>
print -l zsh_demo/*/*<span class="o">(</span>e:<span class="s1">&#39;[[ ! -e $REPLY/malta ]]&#39;</span>:<span class="o">)</span>
<span class="c"># zsh_demo/calculations/africa</span>
<span class="c"># zsh_demo/calculations/asia</span>
<span class="c"># zsh_demo/data/africa</span>
<span class="c"># zsh_demo/data/asia</span>
</code></pre></div>
<p>Let&rsquo;s parse this magic:</p>

<ul>
<li>After the <code>e</code>, the <code>string</code> has to be delimited by a convenient character (in this case, a colon <code>:</code>), and the code must be surrounded by single quotes <code>&#39;</code>, so the actual command is just <code>[[ ! -e $REPLY/malta ]]</code>.</li>
<li>The <code>$REPLY</code> variable contains every file name of the ones specified by the glob <code>zsh_demo/*/*</code> in turn, but only a single file at a time.</li>
<li><code>[[ -e file ]]</code> is a <a href="http://zsh.sourceforge.net/Doc/Release/Conditional-Expressions.html#Conditional-Expressions">conditional expression</a> that returns <em>true</em> if the file exists. We want it to return <em>true</em> when the file called <code>malta</code> <em>doesn&rsquo;t</em> exist, so we reverse it with <code>!</code>.</li>
<li>When the code is executed, the <code>$REPLY</code> variable takes the value of the next file and the code is executed again.</li>
</ul>

<h2>2. Variable transformations</h2>

<h3>Modifiers</h3>

<p>To complicate things even further (or to make them more awesome, depending on your perspective), you can stick one more thing inside the parentheses at the end of your globs: <strong>modifiers</strong>.</p>

<p>Each modifiers is preceded by a colon <code>:</code>, which makes them easily distinguishable from qualifiers.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># A plain old glob</span>
print -l zsh_demo/data/europe/poland/*.txt

<span class="c"># Return the file name (t stands for tail)</span>
print -l zsh_demo/data/europe/poland/*.txt<span class="o">(</span>:t<span class="o">)</span>

<span class="c"># Return the file name without the extension (r stands for remove_extension, I think)</span>
print -l zsh_demo/data/europe/poland/*.txt<span class="o">(</span>:t:r<span class="o">)</span>

<span class="c"># Return the extension</span>
print -l zsh_demo/data/europe/poland/*.txt<span class="o">(</span>:e<span class="o">)</span>

<span class="c"># Return the parent folder of the file (h stands for head)</span>
print -l zsh_demo/data/europe/poland/*.txt<span class="o">(</span>:h<span class="o">)</span>

<span class="c"># Return the parent folder of the parent</span>
print -l zsh_demo/data/europe/poland/*.txt<span class="o">(</span>:h:h<span class="o">)</span>

<span class="c"># Return the parent folder of the first file</span>
print -l zsh_demo/data/europe/poland/*.txt<span class="o">([</span>1<span class="o">]</span>:h<span class="o">)</span>
<span class="c"># Remember you can combine qualifiers and modifiers.</span>
</code></pre></div>
<p>Modifiers are not only for globs, you can also use them with variables (the technical term is <a href="http://zsh.sourceforge.net/Doc/Release/Expansion.html#Parameter-Expansion">parameter expansion</a>):</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># run me, you&#39;ll like it</span>

<span class="nv">my_file</span><span class="o">=(</span>zsh_demo/data/europe/poland/*.txt<span class="o">([</span>1<span class="o">]))</span>
<span class="c"># If you want to store a glob in a variable, you must use parentheses</span>

print -l <span class="nv">$my_file</span>
print -l <span class="nv">$my_file</span><span class="o">(</span>:h<span class="o">)</span>    <span class="c"># this is the syntax we saw before</span>
print -l <span class="k">${</span><span class="nv">my_file</span><span class="p">:</span><span class="nv">h</span><span class="k">}</span>    <span class="c"># I find this syntax more convenient</span>
print -l <span class="k">${</span><span class="nv">my_file</span><span class="p">(:</span><span class="nv">h</span><span class="p">)</span><span class="k">}</span>  <span class="c"># don&#39;t mix the two, or you&#39;ll get an error</span>

print -l <span class="k">${</span><span class="nv">my_file</span><span class="p">:</span><span class="nv">u</span><span class="k">}</span>    <span class="c"># the :u modifier makes the text uppercase</span>
</code></pre></div>
<p>Let&rsquo;s say we wanted to calculate the maximum income for each country, and store it in a file named <code>{country}_max_income.txt</code> in the corresponding calculations folder. We can do this easily using my favorite modifier (<code>:s</code>):</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># run me if you like to run things</span>

<span class="k">for</span> file in zsh_demo/data/**/income.txt <span class="p">;</span> <span class="k">do</span>
    <span class="nv">output_dir</span><span class="o">=</span><span class="k">${</span><span class="nv">file</span><span class="p">:</span><span class="nv">h</span><span class="p">:</span><span class="nv">s</span><span class="p">/data/calculations/</span><span class="k">}</span>
    <span class="nv">country</span><span class="o">=</span><span class="k">${</span><span class="nv">output_dir</span><span class="p">:</span><span class="nv">t</span><span class="k">}</span>
    <span class="nv">output_file</span><span class="o">=</span><span class="s2">&quot;${output_dir}/${country}_max_income.txt&quot;</span>
    <span class="nb">echo</span> <span class="s2">&quot;The max salary is $RANDOM dollars&quot;</span> &gt; <span class="nv">$output_file</span>
<span class="k">done</span>

<span class="c"># let&#39;s see what we just did</span>
grep <span class="s2">&quot;&quot;</span> zsh_demo/calculations/**/*_max_income.txt
</code></pre></div>
<p>Note: The <code>grep &quot;&quot; bunch_of_files</code> command is a quick-and-dirty way to show the name of each file and its contents (we could have also used <code>head bunch_of_files</code>, try it).</p>

<p>So, what&rsquo;s going on here?</p>

<ul>
<li>Each time the <strong>for loop</strong> runs, the <code>$file</code> variable is set to a different income file: <code>zsh_demo/data/africa/kenya/income.txt</code>.</li>
<li>We use the <code>:h</code> modifier to get rid of the file name: <code>zsh_demo/data/africa/kenya/</code>,</li>
<li>and then we use the <code>:s</code> modifier to substitute <code>data</code> with <code>calculations</code>: <code>zsh_demo/calculations/africa/kenya/</code>,</li>
<li>then we store that substituted path in the <code>$output_dir</code> variable.</li>
<li>We use the <code>:t</code> modifier to get the name of the country (<code>kenya</code>) and we store it in the <code>$country</code> variable</li>
<li>Then we stick a slash <code>/</code> between the <code>$output_dir</code> and <code>$country</code> variables, and append <code>_max_income.txt</code> to get our output file path: <code>zsh_demo/calculations/africa/kenya/kenya_max_income.txt</code></li>
<li>The <code>$RANDOM</code> variable gives you a random number every time you call it (it&rsquo;s just a quick way of generating some content).</li>
<li>The right arrow <code>&gt;</code> saves the calculation to the output file.</li>
</ul>

<p><hr></p>

<p>A few more things about the <code>:s</code> modifier:</p>

<ul>
<li>You can use any character to separate the <code>:s</code> and the strings:</li>
</ul>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># run me and see for yourself</span>

<span class="nv">my_variable</span><span class="o">=</span><span class="s2">&quot;path/abcd&quot;</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">my_variable</span><span class="p">:</span><span class="nv">s</span><span class="p">/bc/BC/</span><span class="k">}</span> <span class="c"># path/aBCd</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">my_variable</span><span class="p">:</span><span class="nv">s_bc_BC_</span><span class="k">}</span> <span class="c"># path/aBCd</span>

<span class="nb">echo</span> <span class="k">${</span><span class="nv">my_variable</span><span class="p">:</span><span class="nv">s</span><span class="p">/\//./</span><span class="k">}</span> <span class="c"># path.abcd (escaping the slash \/)</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">my_variable</span><span class="p">:</span><span class="nv">s_</span><span class="p">/_._</span><span class="k">}</span>  <span class="c"># path.abcd (slightly more readable)</span>
<span class="c"># this is useful when you want to substitute the slash (/)</span>
<span class="c"># without having to escape it with a backslash (\)</span>
</code></pre></div>
<ul>
<li>The <code>:s</code> modifier only performs one substitution, if you want to do more, use the <code>:gs</code> modifier (g stands for global)</li>
</ul>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># run me just for fun</span>

<span class="nv">my_variable</span><span class="o">=</span><span class="s2">&quot;aaa&quot;</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">my_variable</span><span class="p">:</span><span class="nv">s</span><span class="p">/a/A/</span><span class="k">}</span> <span class="c"># Aaa</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">my_variable</span><span class="p">:</span><span class="nv">gs</span><span class="p">/a/A/</span><span class="k">}</span> <span class="c"># AAA</span>
</code></pre></div>
<h3>Expansion flags</h3>

<p>Now that you&rsquo;ve learned all about glob operators, glob qualifiers, and modifiers, let&rsquo;s add one more spice to the pot: <strong>expansion flags</strong>.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># run me, it&#39;s free</span>

<span class="c"># Let&#39;s say somebody gave you these updated files</span>
<span class="c"># and told you to replace the old ones</span>
<span class="nb">echo</span> <span class="nv">$RANDOM</span> &gt; zsh_demo/africa_malawi_population_2014.txt
<span class="nb">echo</span> <span class="nv">$RANDOM</span> &gt; zsh_demo/asia_nepal_income_2014.txt
<span class="nb">echo</span> <span class="nv">$RANDOM</span> &gt; zsh_demo/europe_malta_literacy_2014.txt

<span class="c"># How would you move them to their appropriate folders?</span>

<span class="c"># Try this wizardry</span>
<span class="k">for</span> file in zsh_demo/*.txt<span class="p">;</span> <span class="k">do</span>
    <span class="nv">file_info</span><span class="o">=(</span><span class="k">${</span><span class="p">(s._.)file:</span><span class="nv">t</span><span class="k">}</span><span class="o">)</span>
    <span class="nv">continent</span><span class="o">=</span><span class="nv">$file_info</span><span class="o">[</span>1<span class="o">]</span>
    <span class="nv">country</span><span class="o">=</span><span class="nv">$file_info</span><span class="o">[</span>2<span class="o">]</span>
    <span class="nv">data</span><span class="o">=</span><span class="nv">$file_info</span><span class="o">[</span>3<span class="o">]</span>

    mv -f <span class="nv">$file</span> zsh_demo/data/<span class="k">${</span><span class="nv">continent</span><span class="k">}</span>/<span class="k">${</span><span class="nv">country</span><span class="k">}</span>/<span class="k">${</span><span class="nv">data</span><span class="k">}</span>.txt
<span class="k">done</span>

<span class="c"># Check the contents of the files (.) modified (m) in the last</span>
<span class="c"># 5 minutes (m-5) to see what you just did</span>
grep <span class="s2">&quot;&quot;</span> zsh_demo/**/*<span class="o">(</span>.mm-5<span class="o">)</span>
</code></pre></div>
<p>Let&rsquo;s tear down the example to understand what&rsquo;s going on.</p>

<ul>
<li>We are using a <strong>for loop</strong> to cycle through the new text files, and we&rsquo;re storing each file name in the <code>$file</code> variable.</li>
</ul>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="nv">$file</span>
<span class="c"># zsh_demo/europe_malta_literacy_2014.txt</span>
</code></pre></div>
<ul>
<li>We don&rsquo;t want the whole path, so we use the <code>:t</code> modifier to get rid of everything to the left of the first slash <code>/</code>.</li>
</ul>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="k">${</span><span class="nv">file</span><span class="p">:</span><span class="nv">t</span><span class="k">}</span>
<span class="c"># europe_malta_literacy_2014.txt</span>
</code></pre></div>
<ul>
<li>We use the <code>(s)</code> expansion flag to split the file name at each underscore <code>_</code>.</li>
</ul>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="k">${</span><span class="p">(s._.)file:</span><span class="nv">t</span><span class="k">}</span>
<span class="c"># europe malta literacy 2014.txt</span>
</code></pre></div>
<ul>
<li>We surround everything with parentheses so we can save it into an array variable.</li>
</ul>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">file_info</span><span class="o">=</span><span class="k">${</span><span class="p">(s._.)file:</span><span class="nv">t</span><span class="k">}</span>
<span class="nb">echo</span> <span class="nv">$file_info</span>
<span class="c"># the parentheses are missing, file_info contains the wrong information:</span>
<span class="c"># europe_malta_literacy_2014.txt</span>

<span class="nv">file_info</span><span class="o">=(</span><span class="k">${</span><span class="p">(s._.)file:</span><span class="nv">t</span><span class="k">}</span><span class="o">)</span>
<span class="nb">echo</span> <span class="nv">$file_info</span>
<span class="c"># with parentheses, it works:</span>
<span class="c"># europe malta literacy 2014.txt</span>
</code></pre></div>
<ul>
<li>We use an auxiliary variable for continent, country, and data. Since <code>$file_info</code> is now an array, we can refer to its elements by using a numeric index.</li>
</ul>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="k">${</span><span class="nv">file_info</span><span class="p">[3]</span><span class="k">}</span>
<span class="c"># literacy</span>
</code></pre></div>
<ul>
<li>We use the auxiliary variables to specify the path where we want to move the new files <code>zsh_demo/data/${continent}/${country}/${data}.txt</code>.</li>
</ul>

<p>There are a bunch of other flags described in the <a href="http://zsh.sourceforge.net/Doc/Release/Expansion.html#Parameter-Expansion">14.3.1 section of the manual</a>. Check them out if you&rsquo;re curious. We have already covered the split expansion flag <code>(s)</code>; the only other one I use is the join expansion flag <code>(j)</code>, which does the opposite of the split flag.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">my_array</span><span class="o">=(</span>a b c d<span class="o">)</span>
<span class="nb">echo</span> <span class="k">${</span><span class="p">(j.-.)my_array</span><span class="k">}</span>
<span class="c"># a-b-c-d</span>

<span class="c"># Since we are joining using dots (.), it makes more sense to</span>
<span class="c"># use underscores (_) to separate the dots and the j</span>
<span class="nb">echo</span> <span class="k">${</span><span class="p">(j_._)my_array</span><span class="k">}</span>
<span class="c"># a.b.c.d</span>
</code></pre></div>
<h2>3. Magic tabbing</h2>

<h3>Event designators</h3>

<p>Let&rsquo;s introduce the last member of our Zsh jargon family: after glob operators and qualifiers, modifiers and expansion flags, I give you <strong>event designators</strong>.</p>

<p>An event designator references one of the commands that we have previously entered. They always start with a bang <code>!</code>:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># show the previous command</span>
<span class="nb">echo </span>a b c
!! <span class="c"># instead of pressing &lt;Enter&gt;, press &lt;Tab&gt;, then press &lt;Enter&gt;</span>

<span class="c"># show two commands ago</span>
<span class="nb">echo </span>d e f
<span class="nb">echo </span>g h i
!-2 <span class="c"># press &lt;Tab&gt;, then press &lt;Enter&gt;</span>
</code></pre></div>
<p>Note: If you press <code>&lt;Enter&gt;</code> instead of <code>&lt;Tab&gt;</code>, the event designator will also get replaced, but you&rsquo;ll still have to press <code>&lt;Enter&gt;</code> one more time to run it.</p>

<p>I find that these designators are not super useful by themselves because pressing the up arrow key is all we need to do to pull up the previous command (use <code>Control R</code> if you get tired of pressing). When they really come in handy is to add previous arguments to our current command.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># add the last argument</span>
ls zsh_demo/data/asia/laos/population.txt
ls -l !!1 <span class="c"># press &lt;Tab&gt;, then press &lt;Enter&gt;</span>

<span class="c"># add all the previous arguments</span>
<span class="nb">echo </span>a b c
print -l !!* <span class="c"># press &lt;Tab&gt;, then press &lt;Enter&gt;</span>
</code></pre></div>
<p>So, we reference previous arguments in two steps:</p>

<ol>
<li>Specify which command you are interested in

<ul>
<li>The previous command <code>!!</code> is the one you&rsquo;ll use most often.</li>
<li>If you want to go back farther, use the minus sign <code>-</code> and a number: <code>!-2</code>, <code>!-3</code>.</li>
<li>You can also use the current command <code>!#</code></li>
</ul></li>
<li>Pick what arguments you want to reuse

<ul>
<li>To pick an argument from the previous command, just add a number <code>!!1</code>, <code>!!2</code>. Use <code>!!$</code> for the last argument.</li>
<li>To pick an argument from two or more commands ago, add a colon <code>:</code> before the number <code>!-2:1</code> (because<code>!-21</code> means something else).</li>
<li>If you want to reference all the arguments, use an asterisk <code>*</code> <code>!!*</code> <code>!-2:*</code>.</li>
<li>If you want skip all the arguments except the first one or two, add a number before the asterisk <code>!!2*</code>, <code>!-2:2*</code>.</li>
</ul></li>
</ol>

<p>Some useful examples</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">mv zsh_demo/data/asia/laos/population.txt !#1
<span class="c"># press &lt;Tab&gt;</span>
<span class="c"># now you can easily change the second argument</span>
<span class="c"># (use Control W to delete every up to the first slash)</span>

ls zsh_demo/data/europe/malta/literacy.txt
awk <span class="s1">&#39;$1 &gt; 3&#39;</span> !<span class="err">$</span>
<span class="c"># press &lt;Tab&gt;</span>
<span class="c"># !$ is a shortcut for !!$</span>

ls zsh_demo/*/*/nepal/literacy.txt
ls zsh_demo/*/*/malta/literacy.txt
ls -l !-2:1
<span class="c"># press &lt;Tab&gt;</span>
<span class="c"># now you can see the details of the nepal file</span>
</code></pre></div>
<p>If you don&rsquo;t believe there is such a thing as being <em>too productive</em>, check out the <a href="http://zsh.sourceforge.net/Doc/Release/Expansion.html#History-Expansion">history expansion section of the manual</a> for additional shortcuts.</p>

<p>Pressing <code>&lt;Tab&gt;</code> lets you expand not only old commands, but globs, variables (when they use the <code>${}</code> syntax), and even lazily-typed paths!</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">ls zsh_demo/*/*/nepal/literacy.txt
<span class="c"># press &lt;Tab&gt;</span>

<span class="nv">my_var</span><span class="o">=</span><span class="s2">&quot;1 2 3&quot;</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">my_var</span><span class="k">}</span>
<span class="c"># press &lt;Tab&gt;</span>


ls z/d/a/l
<span class="c"># press &lt;Tab&gt;</span>
<span class="c"># Mind blown!</span>
</code></pre></div>
<h2>Bonus tips</h2>

<p>There is a ton of stuff we haven&rsquo;t covered, but I can point you to other people&rsquo;s awesome tips. They are all totally worth it:</p>

<ul>
<li><p>Andrew Hays encourages us to <a href="http://www.andrewhays.net/2012/11/29/love-your-terminal.html">love our terminal</a> by installing the elegant <a href="http://ethanschoonover.com/solarized">Solarized color scheme</a>, and customizing our prompt. Follow his instructions and make all those hours in front of your terminal a more enjoyable experience.</p></li>
<li><p>Danilo Petrozzi over at Zsh Wiki shares a powerful alternative to global aliases. If you find yourself typing stuff like <code>| head | column -t | less -S</code> at the end of your commands, <a href="http://zshwiki.org/home/examples/zleiab">check out his method</a> to turn any sequence of characters into a convenient snippet.</p></li>
<li><p>Also at <a href="http://zshwiki.org/home/builtin/functions/zmv">Zsh Wiki</a>, learn about a way to rename multiple files by using the <code>zmv</code> command. It&rsquo;s extremely convenient for replacing spaces with underscores, changing file extensions, and renaming files located in a nested folder structure. <strong>Always</strong> run <code>zmv</code> using the <code>-n</code> option once, so you are know what the command will actually do.</p></li>
<li><p>We used brace expansion multiple times in this tutorial, but we didn&rsquo;t cover all of its features. Tomasz Muras wrote <a href="http://jmuras.com/blog/2012/brace-expansion-in-bash-and-zsh/">a nice post</a> about it.</p></li>
<li><p>I wasn&rsquo;t able to find a blog post explaining <a href="http://zsh.sourceforge.net/Doc/Release/Parameters.html#Array-Parameters">associative arrays</a>, but I&rsquo;ve found them incredibly useful to deal with sets of parameters. If there&rsquo;s interest, I might go into them in a future post.</p></li>
</ul>

<h2>Parting thoughts</h2>

<p>I&rsquo;ve you read this entire thing in one sitting your brain is probably melting. Don&rsquo;t fret about remembering every little detail. What&rsquo;s important is to realize that there are easy ways of doing a lot of things that you didn&rsquo;t know could be done, and recalling where to go for additional information.</p>

<p>I have a file where I keep all my Zsh snippets. Every time I have to look up the syntax for a command, I open up the file and I write it down. I recommend you do the same. It&rsquo;s the act of progressively improving this file that will help you achieve mastery.</p>

<p>Feel free to leave a comment if you&rsquo;d like to share a tip.</p>

        ]]></description>
      </item>
    
      <item>
        <title>Switching Between Long and Wide Formats in R</title>
        <link>http://reasoniamhere.com/2013/09/26/switching-between-long-and-wide-formats-in-r</link>
        <author>Nacho Caballero</author>
        <pubDate>2013-09-26T00:00:00-04:00</pubDate>
        <guid>http://reasoniamhere.com/2013/09/26/switching-between-long-and-wide-formats-in-r</guid>
        <description><![CDATA[
           <p>This is a basic tutorial in R for switching between the two most common data formats: wide and long. The example dataset we will use is made up of <a href="https://en.wikipedia.org/wiki/Rt_pcr">RT-PCR</a> threshold cycle (Ct) values under two conditions (A and B), with two replicates each.</p>

<!--excerpt-->

<p>Download the file by running this in your command line:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">wget https://raw.github.com/nachocab/nachocab.github.io/master/assets/pcr.txt
</code></pre></div>
<p>Once you have the file, open up an R session and load it in a variable. Instead of creating multiple variables, we will be proactive and create a list variable <code>d</code> that will hold them all. This makes them much easier to manage.</p>
<div class="highlight"><pre><code class="language-r" data-lang="r">d <span class="o">&lt;-</span> <span class="kt">list</span><span class="p">()</span>
d<span class="o">$</span>wide <span class="o">&lt;-</span> read.csv<span class="p">(</span><span class="s">&quot;pcr.txt&quot;</span><span class="p">,</span> sep <span class="o">=</span> <span class="s">&quot;\t&quot;</span><span class="p">)</span> <span class="c1"># columns are separated by tabs</span>
d<span class="o">$</span>wide
<span class="c1">#       gene    A1    A2    B1    B2</span>
<span class="c1"># 1   GENE_1 35.41 36.60 29.96 29.73</span>
<span class="c1"># 2   GENE_2 36.60 23.45 24.39 24.74</span>
<span class="c1"># 3   GENE_3 29.96 23.30 32.17 25.94</span>
<span class="c1"># 4   GENE_4 29.73 22.84 31.66 26.22</span>
<span class="c1"># 5   GENE_5 34.46 22.79 31.39 24.75</span>
<span class="c1"># 6   GENE_6 35.66 21.37 31.34 24.72</span>
<span class="c1"># 7   GENE_7 33.28 21.74 31.10 25.39</span>
<span class="c1"># 8   GENE_8 33.03 22.96 30.90 25.65</span>
<span class="c1"># 9   GENE_9 26.58 22.87 31.14 30.57</span>
<span class="c1"># 10 GENE_10 26.05 25.18 31.03 29.99</span>
<span class="c1"># 11 CONTROL 26.60 25.60 26.03 25.79</span>
</code></pre></div>
<p>This variable is formatted in the typical style used in spreadsheets (it is known as <em>wide format</em> because each data group corresponds to a different column), but for some calculations it is easier to use a more redundant format called a <em>long format</em> because each data item corresponds to a different row.</p>

<p>The easiest way to convert from wide to long is to use the <code>reshape2</code> package.</p>
<div class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Install the package</span>
install.packages<span class="p">(</span><span class="s">&quot;reshape2&quot;</span><span class="p">)</span>

<span class="c1"># And use it</span>
<span class="kn">library</span><span class="p">(</span>reshape2<span class="p">)</span>
d<span class="o">$</span>long <span class="o">&lt;-</span> melt<span class="p">(</span>d<span class="o">$</span>wide<span class="p">)</span> <span class="c1"># Using gene as id variables</span>
<span class="c1"># rename the columns</span>
<span class="kp">colnames</span><span class="p">(</span>d<span class="o">$</span>long<span class="p">)</span> <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="s">&quot;gene&quot;</span><span class="p">,</span> <span class="s">&quot;sample_id&quot;</span><span class="p">,</span> <span class="s">&quot;ct_value&quot;</span><span class="p">)</span>

d<span class="o">$</span>long
<span class="c1">#       gene sample_id ct_value</span>
<span class="c1"># 1   GENE_1        A1    35.41</span>
<span class="c1"># 2   GENE_2        A1    36.60</span>
<span class="c1"># 3   GENE_3        A1    29.96</span>
<span class="c1"># 4   GENE_4        A1    29.73</span>
<span class="c1"># 5   GENE_5        A1    34.46</span>
<span class="c1"># 6   GENE_6        A1    35.66</span>
<span class="c1"># 7   GENE_7        A1    33.28</span>
<span class="c1"># 8   GENE_8        A1    33.03</span>
<span class="c1"># 9   GENE_9        A1    26.58</span>
<span class="c1"># 10 GENE_10        A1    26.05</span>
<span class="c1"># 11 CONTROL        A1    26.60</span>
<span class="c1"># 12  GENE_1        A2    36.60</span>
<span class="c1"># 13  GENE_2        A2    23.45</span>
<span class="c1"># 14  GENE_3        A2    23.30</span>
<span class="c1"># 15  GENE_4        A2    22.84</span>
<span class="c1"># 16  GENE_5        A2    22.79</span>
<span class="c1"># 17  GENE_6        A2    21.37</span>
<span class="c1"># 18  GENE_7        A2    21.74</span>
<span class="c1"># 19  GENE_8        A2    22.96</span>
<span class="c1"># 20  GENE_9        A2    22.87</span>
<span class="c1"># 21 GENE_10        A2    25.18</span>
<span class="c1"># ...</span>
</code></pre></div>
<p>The long format makes it easy to perform operations on subsets of the data. For example, say we want to calculate the mean of the A samples for each gene. First we will need an extra variable to distinguish between the sample groups. We can create it by simply removing the numbers from <code>sample_id</code>.</p>
<div class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># The `gsub` function has three arguments: the pattern, the replacement and the input. Run ?gsub for more info.</span>
d<span class="o">$</span>long<span class="o">$</span>sample_group <span class="o">&lt;-</span> <span class="kp">gsub</span><span class="p">(</span><span class="s">&quot;\\d&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> d<span class="o">$</span>long<span class="o">$</span>sample_id<span class="p">)</span>
d<span class="o">$</span>long

<span class="c1">#       gene sample_id ct_value sample_group</span>
<span class="c1"># ...</span>
<span class="c1"># 19  GENE_8        A2    22.96            A</span>
<span class="c1"># 20  GENE_9        A2    22.87            A</span>
<span class="c1"># 21 GENE_10        A2    25.18            A</span>
<span class="c1"># 22 CONTROL        A2    25.60            A</span>
<span class="c1"># 23  GENE_1        B1    29.96            B</span>
<span class="c1"># 24  GENE_2        B1    24.39            B</span>
<span class="c1"># 25  GENE_3        B1    32.17            B</span>
<span class="c1"># 26  GENE_4        B1    31.66            B</span>
<span class="c1"># 27  GENE_5        B1    31.39            B</span>
<span class="c1"># ...</span>
</code></pre></div>
<p><em>NOTE</em>: In R, backslashes <code>\</code> in <a href="http://www.regular-expressions.info/quickstart.html">regular expressions</a> must be escaped with an extra backslash (for example, <code>\\d</code>).</p>

<p>Now we can use the <code>aggregate</code> function to calculate the mean Ct value and standard deviation for each gene under each condition.</p>
<div class="highlight"><pre><code class="language-r" data-lang="r">d<span class="o">$</span>long_by_group <span class="o">&lt;-</span> aggregate<span class="p">(</span>ct_value <span class="o">~</span> sample_group <span class="o">+</span> gene<span class="p">,</span> data <span class="o">=</span> d<span class="o">$</span>long<span class="p">,</span> <span class="kp">mean</span><span class="p">)</span>
<span class="kp">colnames</span><span class="p">(</span>d<span class="o">$</span>long_by_group<span class="p">)[</span><span class="m">3</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="s">&quot;mean_ct_value&quot;</span>
d<span class="o">$</span>long_by_group<span class="o">$</span>sd <span class="o">&lt;-</span> aggregate<span class="p">(</span>ct_value <span class="o">~</span> sample_group <span class="o">+</span> gene<span class="p">,</span> data <span class="o">=</span> d<span class="o">$</span>long<span class="p">,</span> sd<span class="p">)[,</span><span class="m">3</span><span class="p">]</span>

d<span class="o">$</span>long_by_group
<span class="c1">#    sample_group    gene mean_ct_value        sd</span>
<span class="c1"># 1             A CONTROL        26.100  0.707107</span>
<span class="c1"># 2             B CONTROL        25.910  0.169706</span>
<span class="c1"># 3             A  GENE_1        36.005  0.841457</span>
<span class="c1"># 4             B  GENE_1        29.845  0.162635</span>
<span class="c1"># 5             A GENE_10        25.615  0.615183</span>
<span class="c1"># 6             B GENE_10        30.510  0.735391</span>
<span class="c1"># ...</span>
</code></pre></div>
<p>This function is a bit unwieldy (for example, it reorders the rows and changes the column names), so it&rsquo;s worth to pay attention to what the output looks like. The tilde <code>~</code> expression is called a formula, you can read more about it <a href="http://ww2.coastal.edu/kingw/statistics/R-tutorials/formulae.html">here</a>.</p>

<p>Now that we have calculated the mean and standard deviation for each gene-sample_group pair, it is easy to convert them back to wide format using <code>dcast</code>, a function from the <code>reshape2</code> package.</p>
<div class="highlight"><pre><code class="language-r" data-lang="r">d<span class="o">$</span>wide_mean_by_group <span class="o">&lt;-</span> dcast<span class="p">(</span>d<span class="o">$</span>long_by_group<span class="p">,</span> gene <span class="o">~</span> sample_group<span class="p">,</span> value.var <span class="o">=</span> <span class="s">&quot;mean_ct_value&quot;</span><span class="p">)</span>

d<span class="o">$</span>wide_mean_by_group
<span class="c1">#       gene      A      B</span>
<span class="c1"># 1  CONTROL 26.100 25.910</span>
<span class="c1"># 2   GENE_1 36.005 29.845</span>
<span class="c1"># 3  GENE_10 25.615 30.510</span>
<span class="c1"># 4   GENE_2 30.025 24.565</span>
<span class="c1"># 5   GENE_3 26.630 29.055</span>
<span class="c1"># 6   GENE_4 26.285 28.940</span>
<span class="c1"># 7   GENE_5 28.625 28.070</span>
<span class="c1"># 8   GENE_6 28.515 28.030</span>
<span class="c1"># 9   GENE_7 27.510 28.245</span>
<span class="c1"># 10  GENE_8 27.995 28.275</span>
<span class="c1"># 11  GENE_9 24.725 30.855</span>

d<span class="o">$</span>wide_sd_by_group <span class="o">&lt;-</span> dcast<span class="p">(</span>d<span class="o">$</span>long_by_group<span class="p">,</span> gene <span class="o">~</span> sample_group<span class="p">,</span> value.var <span class="o">=</span> <span class="s">&quot;sd&quot;</span><span class="p">)</span>

d<span class="o">$</span>wide_sd_by_group
<span class="c1">#       gene         A        B</span>
<span class="c1"># 1  CONTROL  0.707107 0.169706</span>
<span class="c1"># 2   GENE_1  0.841457 0.162635</span>
<span class="c1"># 3  GENE_10  0.615183 0.735391</span>
<span class="c1"># 4   GENE_2  9.298454 0.247487</span>
<span class="c1"># 5   GENE_3  4.709331 4.405275</span>
<span class="c1"># 6   GENE_4  4.871966 3.846661</span>
<span class="c1"># 7   GENE_5  8.251936 4.695189</span>
<span class="c1"># 8   GENE_6 10.104556 4.681047</span>
<span class="c1"># 9   GENE_7  8.160012 4.037580</span>
<span class="c1"># 10  GENE_8  7.120565 3.712311</span>
<span class="c1"># 11  GENE_9  2.623366 0.403051</span>
</code></pre></div>
<p>An easy way to remember how to use the formula in <code>dcast</code> is to think <code>row ~ column</code>. In our case, we have a row for each gene, and a column for each sample group.</p>

        ]]></description>
      </item>
    
      <item>
        <title>AWK GTF! How to Analyze a Transcriptome Like a Pro - Part 3</title>
        <link>http://reasoniamhere.com/2013/09/18/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-3</link>
        <author>Nacho Caballero</author>
        <pubDate>2013-09-18T00:00:00-04:00</pubDate>
        <guid>http://reasoniamhere.com/2013/09/18/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-3</guid>
        <description><![CDATA[
           <p>This post belongs to a 3-part series on AWK: <a href="http://reasoniamhere.com/2013/09/16/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-1">Part 1</a> - <a href="http://reasoniamhere.com/2013/09/17/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-2">Part 2</a> - <strong>Part 3</strong></p>

<p>We finished <a href="http://reasoniamhere.com/2013/09/17/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-2">Part 2</a> by creating an associative array, increasing the value of each of its keys for every line that contained a matching key, and used the <code>END</code> rule to print each key&rsquo;s final count.</p>

<!--excerpt-->

<p>In this post, we will apply the translator pattern to turn the gene symbols used in the <a href="http://reasoniamhere.com/2013/09/16/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-1/#get_the_data">transcriptome</a> we have been working with into official <a href="http://www.genenames.org/cgi-bin/hgnc_stats">HGNC symbols</a>.</p>

<h2>Calling AWK with an external file</h2>

<p>We have been calling AWK directly from the command line, but this approach can be limiting sometimes. The alternative is to use the <code>-f</code> option to tell AWK where the code is (in this case, in the <code>source_counter.awk</code> file).</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># create the instructions for AWK</span>
<span class="nb">echo</span> <span class="s1">&#39;NR &gt; 5 {</span>
<span class="s1">    source_counter[$2] += 1</span>
<span class="s1">}</span>

<span class="s1">END {</span>
<span class="s1">    for (source_name in source_counter){</span>
<span class="s1">        print source_name, source_counter[source_name]</span>
<span class="s1">    }</span>
<span class="s1">}&#39;</span> &gt; source_counter.awk

<span class="c"># run AWK</span>
awk -f source_counter.awk transcriptome.gtf

HAVANA 2257550
ENSEMBL 357012
</code></pre></div>
<p><code>NR</code> is a special variable that contains the current line number (AWK calls lines records, which explains the R). <code>NR &gt; 5</code> tells AWK to execute the code between the curly braces only when the line number is greater than 5, so it skips the first 5 lines. We do this to get rid of the header lines that appear at the beginning of the Gencode transcriptome file.</p>

<p>Remember you still have to provide AWK with an input file (<code>transcriptome.gtf</code>) or use a pipe (<code>cat transcriptome.gtf | awk -f source_counter.awk</code>). If you don&rsquo;t, AWK will just sit there quietly until it receives an input that will never arrive. This is bound to happen to you at some point; when it does, press <code>ctrl c</code>, smack your forehead and start again.</p>

<h2>Splitting strings</h2>

<p>The following two commands create the files that we will use for the rest of the post. Run them so you can play along.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s1">&#39;</span>
<span class="s1">ZYX_CTSL 40</span>
<span class="s1">WVU_CTSV 21</span>
<span class="s1">TSR_MYCL 11</span>
<span class="s1">QPO_KMT2A 155</span>
<span class="s1">NML_HSP90AB1 36</span>
<span class="s1">KJI_CAPN7 52</span>
<span class="s1">HGF_DACH2 84</span>
<span class="s1">EDC_IFNA14 1&#39;</span> &gt; exon_counts.txt

<span class="c"># the format of the translator is UNOFFICIAL_GENE_NAME OFFICIAL_GENE_NAME</span>
<span class="nb">echo</span> <span class="s1">&#39;</span>
<span class="s1">CTSL CTSL1</span>
<span class="s1">FLJ31037 CTSL1</span>
<span class="s1">MGC125957 CTSL2</span>
<span class="s1">CTSU CTSL2</span>
<span class="s1">CTSV CTSL2</span>
<span class="s1">CATL2 CTSL2</span>
<span class="s1">MYCL MYCL1</span>
<span class="s1">LMYC MYCL1</span>
<span class="s1">KMT2A MLL</span>
<span class="s1">ALL-1 MLL</span>
<span class="s1">HTRX1 MLL</span>
<span class="s1">KMT2A MLL</span>
<span class="s1">CXXC7 MLL</span>
<span class="s1">TET1-MLL MLL</span>
<span class="s1">MLL1A MLL</span>
<span class="s1">FLJ11783 MLL&#39;</span> &gt; translator.txt
</code></pre></div>
<p>Imagine that you found <code>exon_counts.txt</code> in the supplementary materials section of a paper from a rival lab, and you want to compare their results with yours. Unfortunately, they seem to enjoy prepending their gene symbols with a strange (but vaguely familiar) code followed by an underscore. How do we get rid of it?</p>

<p>AWK to the rescue. We can use <code>split</code>, one of its <a href="http://www.gnu.org/software/gawk/manual/html_node/String-Functions.html">functions</a> to manipulate strings:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s2">&quot;HOLY-GUACAMOLE&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;{ split($1, words, &quot;-&quot;); print words[2] }&#39;</span> <span class="c"># GUACAMOLE</span>
<span class="nb">echo</span> <span class="s2">&quot;HOLY-GUACAMOLE&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;{ split($1, words, &quot;-&quot;); print words[1] }&#39;</span> <span class="c"># HOLY</span>
<span class="nb">echo</span> <span class="s2">&quot;HOLY-GUACAMOLE-CHIMICHANGA&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;</span>
<span class="s1">{</span>
<span class="s1">    split($1, words, &quot;-&quot;)</span>
<span class="s1">    print &quot;I would like&quot;, words[2], &quot;in my&quot;, words[3] &quot;, please&quot;</span>
<span class="s1">}&#39;</span> <span class="c"># I would like GUACAMOLE in my CHIMICHANGA, please</span>
</code></pre></div>
<p>Its first argument is the <strong>string</strong> that we want to split, the second is the name of the <strong>array</strong> variable that will contain the pieces of the string that we split, and the third is the <strong>delimiter</strong> that we want to use to separate the string into pieces. In this case, we chose to call the array variable <code>words</code>. An array can be considered as a special case of the associative array, where the keys are numbers, instead of words.</p>

<p>The semicolon in the first two commands is just a way to be lazy and write more than one function (<code>split</code>, <code>print</code>) in the same line.</p>

<p>Notice a small subtlety hidden among the Tex-Mex: there is no comma between <code>words[3]</code> and <code>&quot;, please&quot;</code>. If there was, the output would be <code>CHIMICHANGA , please</code>. Because there is no comma, AWK simply appends the two strings without inserting the default output separator (the space).</p>

<p>Now we are ready to get rid of the reverse-alphabetical madness.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk <span class="s1">&#39;{</span>
<span class="s1">    split($1, words, &quot;_&quot;)</span>
<span class="s1">    print words[2], $2</span>
<span class="s1">}&#39;</span> exon_counts.txt &gt; exon_counts2.txt

cat exon_counts2.txt

CTSL 40
CTSV 21
MYCL 11
KMT2A 155
HSP90AB1 36
CAPN7 52
DACH2 84
IFNA14 1
</code></pre></div>
<h2>Building a translation dictionary</h2>

<p>Watch the magic unfold:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk -v <span class="nv">translations_file</span><span class="o">=</span><span class="s2">&quot;translator.txt&quot;</span> <span class="s1">&#39;</span>
<span class="s1">BEGIN{</span>
<span class="s1">    while (getline &lt; translations_file) {</span>
<span class="s1">        translations[$1] = $2</span>
<span class="s1">    }</span>
<span class="s1">    close(translations_file)</span>
<span class="s1">}</span>

<span class="s1">{</span>
<span class="s1">    if (translations[$1] != &quot;&quot;){</span>
<span class="s1">       $1 = translations[$1]</span>
<span class="s1">       $3 = &quot;translated&quot;</span>
<span class="s1">    } else {</span>
<span class="s1">       $3 = &quot;untranslated&quot;</span>
<span class="s1">    }</span>
<span class="s1">   print</span>
<span class="s1">}&#39;</span> exon_counts2.txt

<span class="c"># output</span>
CTSL1 <span class="m">40</span> translated
CTSL2 <span class="m">21</span> translated
MYCL1 <span class="m">11</span> translated
MLL <span class="m">155</span> translated
HSP90AB1 <span class="m">36</span> untranslated
CAPN7 <span class="m">52</span> untranslated
DACH2 <span class="m">84</span> untranslated
IFNA14 <span class="m">1</span> untranslated
</code></pre></div>
<p>I always have to look up the exact syntax for the translator pattern because I never remember, but it&rsquo;s so useful that I keep it in an easily accessible <a href="https://github.com/nachocab/tips_and_tricks/blob/master/bash_tricks.sh">text file</a>, along with all the other useful-but-impossible-to-remember commands.</p>

<p>A lot is going on here.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk -v <span class="nv">translations_file</span><span class="o">=</span><span class="s2">&quot;translator.txt&quot;</span> <span class="s1">&#39;...&#39;</span> exon_counts2.txt
</code></pre></div>
<p>The <code>-v</code> option is used to create variables that can be used by AWK in the code that goes between the single quotes. In this case we are creating a variable called <code>translations_file</code> with value <code>&quot;translator.txt&quot;</code>. Due to the Holy UNIX Commandments, no spaces are allowed around the equals sign (this rule doesn&rsquo;t apply inside AWK, though).</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">BEGIN<span class="o">{</span> ... <span class="o">}</span>
</code></pre></div>
<p>The <code>BEGIN</code> rule does the opposite of the <code>END</code> rule: it is true before the input file (<code>exon_counts2.txt</code>) is read, and false thereafter.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="k">while</span> <span class="o">(</span>condition<span class="o">)</span> <span class="o">{</span> ... <span class="o">}</span>
</code></pre></div>
<p>Similar to the <code>for</code> loop that we saw in the previous post, there is also a <code>while</code> loop, which runs until the condition between the parentheses stops being true.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="k">while</span> <span class="o">(</span>getline &lt; translations_file<span class="o">)</span> <span class="o">{</span>
    translations<span class="o">[</span><span class="nv">$1</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$2</span>
<span class="o">}</span>
close<span class="o">(</span>translations_file<span class="o">)</span>
</code></pre></div>
<p><code>getline &lt; some_file</code> is an <a href="http://www.gnu.org/software/gawk/manual/html_node/Getline.html#Getline">internal</a> AWK command that lets you read the next line from a different file than the standard input file. After the line is read, the dollar <code>$</code> variables are updated, so we can use <code>$1</code> and <code>$2</code> just like we usually do. The file must then be closed to avoid angering the UNIX gods.</p>

<p><em>NOTE</em>: There is a lot of wizardry that surrounds the <code>getline</code> command. Ninety percent of the time, the translator pattern is enough. If you want to do fancier stuff, like using a translator file with a different input delimiter than the one used by the input file, it&rsquo;s worth spending an hour reading the <a href="http://www.gnu.org/software/gawk/manual/html_node/Getline.html#Getline">documentation</a> to understand all the nitty-gritties.</p>

<p><code>translations</code> is an associative array that has the bad gene symbols as keys, and the official gene symbols as values. The <code>translator.txt</code> file doesn&rsquo;t have any repeats in column one, so we can be sure that each bad symbol only has one good translation. But our toy translator file doesn&rsquo;t have all the gene symbols that appear in <code>exon_counts2.txt</code> (HSP90AB1 is missing, for example).</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="k">if</span> <span class="o">(</span>translations<span class="o">[</span><span class="nv">$1</span><span class="o">]</span> !<span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">){</span>
   <span class="nv">$1</span> <span class="o">=</span> translations<span class="o">[</span><span class="nv">$1</span><span class="o">]</span>
   <span class="nv">$3</span> <span class="o">=</span> <span class="s2">&quot;translated&quot;</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
   <span class="nv">$3</span> <span class="o">=</span> <span class="s2">&quot;untranslated&quot;</span>
<span class="o">}</span>
</code></pre></div>
<p>We check this by using an <code>if</code> statement, which only executes the code inside the braces if what is between the parentheses is true. In our example, <code>translations[$1]</code> will equal the empty string <code>&quot;&quot;</code> for genes genes that don&rsquo;t have a translation. In those cases, we won&rsquo;t overwrite <code>$1</code>.</p>

<p>The <code>print</code> command without any arguments prints all the fields (AWK calls columns <strong>fields</strong>), including the one we created to know if the gene was translated or not.</p>

<p><hr></p>

<p>I hope this series got you interested in learning more about AWK. From personal experience, once you grok it, you want to use it everywhere. There is a megaton of material we didn&rsquo;t cover, but here is a <a href="http://www.catonmat.net/blog/awk-one-liners-explained-part-one/">great link</a> with many handy AWK one-liners. Feel free to get back to me if you have any questions.</p>

        ]]></description>
      </item>
    
      <item>
        <title>AWK GTF! How to Analyze a Transcriptome Like a Pro - Part 2</title>
        <link>http://reasoniamhere.com/2013/09/17/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-2</link>
        <author>Nacho Caballero</author>
        <pubDate>2013-09-17T00:00:00-04:00</pubDate>
        <guid>http://reasoniamhere.com/2013/09/17/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-2</guid>
        <description><![CDATA[
           <p>This post belongs to a 3-part series on AWK: <a href="http://reasoniamhere.com/2013/09/16/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-1">Part 1</a> - <strong>Part 2</strong> - <a href="http://reasoniamhere.com/2013/09/18/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-3">Part 3</a></p>

<p>Back in <a href="http://reasoniamhere.com/2013/09/16/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-1">Part 1</a>, we learned how to tell AWK to select specific lines from a tab-separated <a href="http://reasoniamhere.com/2013/09/16/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-1/#get_the_data">transcriptome file</a> (using the rule <code>&#39;$3 == &quot;gene&quot;&#39;</code>) and return a specific column (using the <code>print</code> statement inside the curly braces <code>{ }</code>).</p>

<p>In this post, we are going to count how many exons make up each protein-coding gene.</p>

<!--excerpt-->

<h2>Chaining AWK calls</h2>

<p>We will start with the AWK call that we were using before, and we will append a pipe <code>|</code> so it can be used as input for the next AWK call, this time using a space and a semicolon as the delimiter to define what a column is:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk -F <span class="s2">&quot;\t&quot;</span> <span class="s1">&#39;$3 == &quot;gene&quot; { print $9 }&#39;</span> transcriptome.gtf <span class="p">|</span> awk -F <span class="s2">&quot;; &quot;</span> <span class="s1">&#39;{ print $3 }&#39;</span> <span class="p">|</span> head <span class="p">|</span> less -S

gene_type <span class="s2">&quot;pseudogene&quot;</span>
gene_type <span class="s2">&quot;pseudogene&quot;</span>
gene_type <span class="s2">&quot;lincRNA&quot;</span>
gene_type <span class="s2">&quot;lincRNA&quot;</span>
gene_type <span class="s2">&quot;pseudogene&quot;</span>
gene_type <span class="s2">&quot;pseudogene&quot;</span>
gene_type <span class="s2">&quot;protein_coding&quot;</span>
gene_type <span class="s2">&quot;lincRNA&quot;</span>
gene_type <span class="s2">&quot;lincRNA&quot;</span>
gene_type <span class="s2">&quot;pseudogene&quot;</span>
</code></pre></div>
<p>Now that we see what the third column looks like, we can filter for protein-coding genes</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk -F <span class="s2">&quot;\t&quot;</span> <span class="s1">&#39;$3 == &quot;gene&quot; { print $9 }&#39;</span> transcriptome.gtf <span class="p">|</span> <span class="se">\</span>
awk -F <span class="s2">&quot;; &quot;</span> <span class="s1">&#39;$3 == &quot;gene_type \&quot;protein_coding\&quot;&quot;&#39;</span> <span class="p">|</span> <span class="se">\</span>
head <span class="p">|</span> less -S

gene_id <span class="s2">&quot;ENSG00000186092.4&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000186092.4&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;OR4F5&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;OR4F5&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000001094.1&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000237683.5&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000237683.5&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;AL627309.1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;AL627309.1&quot;</span><span class="p">;</span> level 3<span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000235249.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000235249.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;OR4F29&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;OR4F29&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000002860.1&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000185097.2&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000185097.2&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;OR4F16&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;OR4F16&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000002581.1&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000269831.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000269831.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;AL669831.1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;AL669831.1&quot;</span><span class="p">;</span> level 3<span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000269308.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000269308.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;AL645608.2&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;AL645608.2&quot;</span><span class="p">;</span> level 3<span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000187634.6&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000187634.6&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;SAMD11&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;SAMD11&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000040719.8&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000268179.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000268179.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;AL645608.1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;AL645608.1&quot;</span><span class="p">;</span> level 3<span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000188976.6&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000188976.6&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;NOC2L&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;NOC2L&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000040720.1&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000187961.9&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000187961.9&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;KLHL17&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;KLHL17&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000040721.6&quot;</span><span class="p">;</span>
</code></pre></div>
<p>I added a space and a backslash <code>\</code> (not to be confused with the regular slash <code>/</code>) after the first and second pipes to split the code into two lines; this makes it easier to read and it highlights that we are taking two separate steps.</p>

<p>The double quotes around <code>protein_coding</code> are escaped (also with a backslash <code>\&quot;</code>) because they are already contained inside double quotes. To avoid the backslashing drama we can use the partial matching operator <code>~</code> instead of the total equality operator <code>==</code>.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk -F <span class="s2">&quot;\t&quot;</span> <span class="s1">&#39;$3 == &quot;gene&quot; { print $9 }&#39;</span> transcriptome.gtf <span class="p">|</span> <span class="se">\</span>
awk -F <span class="s2">&quot;; &quot;</span> <span class="s1">&#39;$3 ~ &quot;protein_coding&quot;&#39;</span> <span class="p">|</span> <span class="se">\</span>
head <span class="p">|</span> less -S
</code></pre></div>
<p>The output is the same as before: those lines that contain a <code>protein_coding</code> somewhere in their third column make the partial matching rule true, and they get printed (which is the default behavior when there are no curly braces).</p>

<p>Now we have all the protein-coding genes, but how do we get to the genes that only have one exon? Well, we have to revisit our initial AWK call: we selected lines that corresponded to genes, but we actually want lines that correspond to <em>exons</em>. That&rsquo;s an easy fix, we just change the word &ldquo;gene&rdquo; for the word &ldquo;exon&rdquo;. Everything else stays the same.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk -F <span class="s2">&quot;\t&quot;</span> <span class="s1">&#39;$3 == &quot;exon&quot; { print $9 }&#39;</span> transcriptome.gtf <span class="p">|</span> <span class="se">\</span>
awk -F <span class="s2">&quot;; &quot;</span> <span class="s1">&#39;$3 ~ &quot;protein_coding&quot;&#39;</span> <span class="p">|</span> <span class="se">\</span>
head <span class="p">|</span> less -S

gene_id <span class="s2">&quot;ENSG00000186092.4&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENST00000335137.3&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;OR4F5&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;OR4F5-001&quot;</span><span class="p">;</span> exon_number 1<span class="p">;</span>  exon_id <span class="s2">&quot;ENSE00002319515.1&quot;</span><span class="p">;</span>  level 2<span class="p">;</span> tag <span class="s2">&quot;basic&quot;</span><span class="p">;</span> tag <span class="s2">&quot;CCDS&quot;</span><span class="p">;</span> ccdsid <span class="s2">&quot;CCDS30547.1&quot;</span><span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000001094.1&quot;</span><span class="p">;</span> havana_transcript <span class="s2">&quot;OTTHUMT00000003223.1&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000237683.5&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENST00000423372.3&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;AL627309.1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;AL627309.1-201&quot;</span><span class="p">;</span> exon_number 1<span class="p">;</span>  exon_id <span class="s2">&quot;ENSE00002221580.1&quot;</span><span class="p">;</span>  level 3<span class="p">;</span> tag <span class="s2">&quot;basic&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000237683.5&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENST00000423372.3&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;AL627309.1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;AL627309.1-201&quot;</span><span class="p">;</span> exon_number 2<span class="p">;</span>  exon_id <span class="s2">&quot;ENSE00002314092.1&quot;</span><span class="p">;</span>  level 3<span class="p">;</span> tag <span class="s2">&quot;basic&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000235249.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENST00000426406.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;OR4F29&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;OR4F29-001&quot;</span><span class="p">;</span> exon_number 1<span class="p">;</span>  exon_id <span class="s2">&quot;ENSE00002316283.1&quot;</span><span class="p">;</span>  level 2<span class="p">;</span> tag <span class="s2">&quot;basic&quot;</span><span class="p">;</span> tag <span class="s2">&quot;CCDS&quot;</span><span class="p">;</span> ccdsid <span class="s2">&quot;CCDS41220.1&quot;</span><span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000002860.1&quot;</span><span class="p">;</span> havana_transcript <span class="s2">&quot;OTTHUMT00000007999.1&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000185097.2&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENST00000332831.2&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;OR4F16&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;OR4F16-001&quot;</span><span class="p">;</span> exon_number 1<span class="p">;</span>  exon_id <span class="s2">&quot;ENSE00002324228.1&quot;</span><span class="p">;</span>  level 2<span class="p">;</span> tag <span class="s2">&quot;basic&quot;</span><span class="p">;</span> tag <span class="s2">&quot;CCDS&quot;</span><span class="p">;</span> ccdsid <span class="s2">&quot;CCDS41221.1&quot;</span><span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000002581.1&quot;</span><span class="p">;</span> havana_transcript <span class="s2">&quot;OTTHUMT00000007334.1&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000269831.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENST00000599533.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;AL669831.1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;AL669831.1-201&quot;</span><span class="p">;</span> exon_number 1<span class="p">;</span>  exon_id <span class="s2">&quot;ENSE00003063549.1&quot;</span><span class="p">;</span>  level 3<span class="p">;</span> tag <span class="s2">&quot;basic&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000269831.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENST00000599533.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;AL669831.1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;AL669831.1-201&quot;</span><span class="p">;</span> exon_number 2<span class="p">;</span>  exon_id <span class="s2">&quot;ENSE00003084653.1&quot;</span><span class="p">;</span>  level 3<span class="p">;</span> tag <span class="s2">&quot;basic&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000269831.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENST00000599533.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;AL669831.1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;AL669831.1-201&quot;</span><span class="p">;</span> exon_number 3<span class="p">;</span>  exon_id <span class="s2">&quot;ENSE00003138540.1&quot;</span><span class="p">;</span>  level 3<span class="p">;</span> tag <span class="s2">&quot;basic&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000269308.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENST00000594233.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;AL645608.2&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;AL645608.2-201&quot;</span><span class="p">;</span> exon_number 1<span class="p">;</span>  exon_id <span class="s2">&quot;ENSE00003079649.1&quot;</span><span class="p">;</span>  level 3<span class="p">;</span> tag <span class="s2">&quot;basic&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000269308.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENST00000594233.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;AL645608.2&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;AL645608.2-201&quot;</span><span class="p">;</span> exon_number 2<span class="p">;</span>  exon_id <span class="s2">&quot;ENSE00003048391.1&quot;</span><span class="p">;</span>  level 3<span class="p">;</span> tag <span class="s2">&quot;basic&quot;</span><span class="p">;</span>
</code></pre></div>
<h2>Cleaning up the output</h2>

<p>Before we try to count how many exons belong to the same protein-coding gene, let&rsquo;s simplify the output so we only get the gene names (which are in column 5).</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk -F <span class="s2">&quot;\t&quot;</span> <span class="s1">&#39;$3 == &quot;exon&quot; { print $9 }&#39;</span> transcriptome.gtf <span class="p">|</span> <span class="se">\</span>
awk -F <span class="s2">&quot;; &quot;</span> <span class="s1">&#39;$3 ~ &quot;protein_coding&quot; {print $5}&#39;</span> <span class="p">|</span> <span class="se">\</span>
head

gene_name <span class="s2">&quot;OR4F5&quot;</span>
gene_name <span class="s2">&quot;AL627309.1&quot;</span>
gene_name <span class="s2">&quot;AL627309.1&quot;</span>
gene_name <span class="s2">&quot;OR4F29&quot;</span>
gene_name <span class="s2">&quot;OR4F16&quot;</span>
gene_name <span class="s2">&quot;AL669831.1&quot;</span>
gene_name <span class="s2">&quot;AL669831.1&quot;</span>
gene_name <span class="s2">&quot;AL669831.1&quot;</span>
gene_name <span class="s2">&quot;AL645608.2&quot;</span>
gene_name <span class="s2">&quot;AL645608.2&quot;</span>
</code></pre></div>
<p>This is sort of what we want. We could chain another AWK call using <code>-F &quot; &quot;</code>, and pick the second column (which would get rid of the <code>gene_name</code>). Feel free to try that approach if you are curious.</p>

<p>We can also take a shortcut by using the <code>tr -d</code> command, which deletes whatever characters appear in double quotes. For example, to remove every vowel from a sentence:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s2">&quot;This unix thing is cool&quot;</span> <span class="p">|</span> tr -d <span class="s2">&quot;aeiou&quot;</span> <span class="c"># Ths nx thng s cl</span>
</code></pre></div>
<p>Let&rsquo;s try deleting all the semicolons and quotes before the second AWK call:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk -F <span class="s2">&quot;\t&quot;</span> <span class="s1">&#39;$3 == &quot;exon&quot; { print $9 }&#39;</span> transcriptome.gtf <span class="p">|</span> <span class="se">\</span>
tr -d <span class="s2">&quot;;\&quot;&quot;</span> <span class="p">|</span> <span class="se">\</span>
awk -F <span class="s2">&quot; &quot;</span> <span class="s1">&#39;$6 == &quot;protein_coding&quot; {print $10}&#39;</span> <span class="p">|</span> <span class="se">\</span>
head

OR4F5
AL627309.1
AL627309.1
OR4F29
OR4F16
AL669831.1
AL669831.1
AL669831.1
AL645608.2
AL645608.2
</code></pre></div>
<p>Run <code>awk -F &quot;\t&quot; &#39;$3 == &quot;exon&quot; { print $9 }&#39; transcriptome.gtf | tr -d &quot;;\&quot;&quot; | head</code> to understand what the input to the second AWK call looks like. It&rsquo;s just words separated by spaces; the sixth word corresponds to the gene type, and the tenth word to the gene name.</p>

<h2>Counting genes</h2>

<p>There is one more concept we need to introduce before we start counting. AWK uses a special rule called <code>END</code>, which is only true once the input is over. See an example:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> -e <span class="s2">&quot;a\na\nb\nb\nb\nc&quot;</span> <span class="p">|</span> <span class="se">\</span>
awk <span class="s1">&#39;</span>
<span class="s1">    { print $1 }</span>

<span class="s1">END { print &quot;Done with letters!&quot; }</span>
<span class="s1">&#39;</span>

a
a
b
b
b
c
Done with letters!
</code></pre></div>
<p>The <code>-e</code> option tells <code>echo</code> to convert each <code>\n</code> into a new line, which is a convenient way of printing multiple lines from a single character string.</p>

<p>In AWK, any amount of whitespace is allowed between the initial and the final quote <code>&#39;</code>. I separated the first rule from the <code>END</code> rule to make them easier to read.</p>

<p>Now we are ready for counting.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> -e <span class="s2">&quot;a\na\nb\nb\nb\nc&quot;</span> <span class="p">|</span> <span class="se">\</span>
awk <span class="s1">&#39;</span>
<span class="s1">    { counter[$1] += 1 }</span>

<span class="s1">END {</span>
<span class="s1">    for (letter in counter){</span>
<span class="s1">        print letter, counter[letter]</span>
<span class="s1">    }</span>
<span class="s1">}</span>
<span class="s1">&#39;</span>

a 2
b 3
c 1
</code></pre></div>
<p>Wow, what is all that madness?</p>

<p>Instead of printing each letter, we manipulate a variable that we called <code>counter</code>. This variable is special because it is followed by brackets <code>[ ]</code>, which makes it an <strong>associative array</strong>, a fancy way of calling a variable that stores key-value pairs.</p>

<p>In this case we chose the values of the first column <code>$1</code> to be the keys of the <code>counter</code> variable, which means there are 3 keys (&ldquo;a&rdquo;, &ldquo;b&rdquo; and &ldquo;c&rdquo;). The values are initialized to 0. For every line in the input, we add a 1 to the value in the array whose key is equal to <code>$1</code>. We use the addition operator <code>+=</code>, a shortcut for <code>counter[$1] = counter[$1] + 1</code>.</p>

<p>When all the lines are read, the <code>END</code> rule becomes true, and the code between the curly braces <code>{ }</code> is executed. The structure <code>for (key in associate_array) { some_code }</code> is called a <code>for</code> loop, and it executes <code>some_code</code> as many times as there are keys in the array. <code>letter</code> is the name that we chose for the variable that cycles through all the keys in <code>counter</code>, and <code>counter[letter]</code> gives the value stored in <code>counter</code> for each <code>letter</code> (which we we calculated in the previous curly brace chunk).</p>

<p>Now we can apply this to the real example:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk -F <span class="s2">&quot;\t&quot;</span> <span class="s1">&#39;$3 == &quot;exon&quot; { print $9 }&#39;</span> transcriptome.gtf <span class="p">|</span> <span class="se">\</span>
tr -d <span class="s2">&quot;;\&quot;&quot;</span> <span class="p">|</span> <span class="se">\</span>
awk -F <span class="s2">&quot; &quot;</span> <span class="s1">&#39;</span>
<span class="s1">$6 == &quot;protein_coding&quot; {</span>
<span class="s1">    gene_counter[$10] += 1</span>
<span class="s1">}</span>

<span class="s1">END {</span>
<span class="s1">    for (gene_name in gene_counter){</span>
<span class="s1">        print gene_name, gene_counter[gene_name]</span>
<span class="s1">    }</span>
<span class="s1">}&#39;</span> &gt; number_of_exons_by_gene.txt

head number_of_exons_by_gene.txt
CAPN6 24
ARL14EPL 3
DACH1 38
IFNA13 1
HSP90AB1 36
CAPN7 52
DACH2 84
IFNA14 1
LARS 188
CAPN8 78
</code></pre></div>
<p>If you are using the real transcriptome, it takes less than a minute to count up one million exons. Pretty impressive.</p>

<p>We saved the output to a file, so now we can use AWK to see how many genes are made up of a single exon.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk <span class="s1">&#39;$2 == 1&#39;</span> number_of_exons_by_gene.txt <span class="p">|</span> wc -l <span class="c"># 1362</span>
</code></pre></div>
<p>In the <a href="http://reasoniamhere.com/2013/09/18/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-3">next post</a> we will use AWK to translate old gene symbols into official HGNC gene symbols.</p>

        ]]></description>
      </item>
    
      <item>
        <title>AWK GTF! How to Analyze a Transcriptome Like a Pro - Part 1</title>
        <link>http://reasoniamhere.com/2013/09/16/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-1</link>
        <author>Nacho Caballero</author>
        <pubDate>2013-09-16T00:00:00-04:00</pubDate>
        <guid>http://reasoniamhere.com/2013/09/16/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-1</guid>
        <description><![CDATA[
           <p>This post belongs to a 3-part series on AWK: <strong>Part 1</strong> - <a href="http://reasoniamhere.com/2013/09/17/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-2">Part 2</a> - <a href="http://reasoniamhere.com/2013/09/18/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-3">Part 3</a></p>

<p>The goal of this tutorial is to show a few of the cool things that the Unix tool AWK can do with tabular data. We will focus on extracting useful information from a <a href="https://en.wikipedia.org/wiki/Transcriptome">transcriptome</a>—because bioinformatics is cool—, but AWK can do its wonders with any kind of text file.</p>

<p>The tutorial has been carefully designed to make it easy for you to play along. So feel free to copy and paste the commands in your Unix terminal.</p>

<!--excerpt-->

<h2>Get the data</h2>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># I recommend using this smaller file...</span>
wget https://raw.github.com/nachocab/nachocab.github.io/master/assets/transcriptome.gtf

<span class="c"># ...but if you&#39;re feeling bold, go ahead and download the whole enchilada</span>
wget ftp://ftp.sanger.ac.uk/pub/gencode/release_18/gencode.v18.annotation.gtf.gz
gzip -dc gencode.v18.annotation.gtf.gz &gt; transcriptome.gtf
</code></pre></div>
<p>Let&rsquo;s see what the file we just downloaded looks like.</p>

<pre><code class="wrap">head transcriptome.gtf

##description: evidence-based annotation of the human genome (GRCh37), version 18 (Ensembl 73)
##provider: GENCODE
##contact: gencode@sanger.ac.uk
##format: gtf
##date: 2013-09-02
chr1    HAVANA  gene    11869   14412   .   +   .   gene_id "ENSG00000223972.4"; transcript_id "ENSG00000223972.4"; gene_type "pseudogene"; gene_status "KNOWN"; gene_name "DDX11L1"; transcript_type "pseudogene"; transcript_status "KNOWN"; transcript_name "DDX11L1"; level 2; havana_gene "OTTHUMG00000000961.2";
chr1    HAVANA  transcript  11869   14409   .   +   .   gene_id "ENSG00000223972.4"; transcript_id "ENST00000456328.2"; gene_type "pseudogene"; gene_status "KNOWN"; gene_name "DDX11L1"; transcript_type "processed_transcript"; transcript_status "KNOWN"; transcript_name "DDX11L1-002"; level 2; tag "basic"; havana_gene "OTTHUMG00000000961.2"; havana_transcript "OTTHUMT00000362751.1";
chr1    HAVANA  exon    11869   12227   .   +   .   gene_id "ENSG00000223972.4"; transcript_id "ENST00000456328.2"; gene_type "pseudogene"; gene_status "KNOWN"; gene_name "DDX11L1"; transcript_type "processed_transcript"; transcript_status "KNOWN"; transcript_name "DDX11L1-002"; exon_number 1;  exon_id "ENSE00002234944.1";  level 2; tag "basic"; havana_gene "OTTHUMG00000000961.2"; havana_transcript "OTTHUMT00000362751.1";
</code></pre>

<p>Holy smokes. Who wrote that and why does he hate me?</p>

<p>That, my friend, is <a href="http://www.gencodegenes.org/releases/18.html">Gencode</a>&rsquo;s human transcriptome. It will seem less intimidating if we look at it one screen at a time</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">less -S transcriptome.gtf

<span class="c">##description: evidence-based annotation of the human genome (GRCh37), version 18 (Ensembl 73)</span>
<span class="c">##provider: GENCODE</span>
<span class="c">##contact: gencode@sanger.ac.uk</span>
<span class="c">##format: gtf</span>
<span class="c">##date: 2013-09-02</span>
chr1    HAVANA  gene    <span class="m">11869</span>   <span class="m">14412</span>   .   +   .   gene_id <span class="s2">&quot;ENSG00000223972.4&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000223972.4&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;DDX11L1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;DDX11L1&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000000961.2&quot;</span><span class="p">;</span>
chr1    HAVANA  transcript  <span class="m">11869</span>   <span class="m">14409</span>   .   +   .   gene_id <span class="s2">&quot;ENSG00000223972.4&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENST00000456328.2&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;DDX11L1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;processed_transcript&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;DDX11L1-002&quot;</span><span class="p">;</span> level 2<span class="p">;</span> tag <span class="s2">&quot;basic&quot;</span><span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000000961.2&quot;</span><span class="p">;</span> havana_transcript <span class="s2">&quot;OTTHUMT00000362751.1&quot;</span><span class="p">;</span>
chr1    HAVANA  exon    <span class="m">11869</span>   <span class="m">12227</span>   .   +   .   gene_id <span class="s2">&quot;ENSG00000223972.4&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENST00000456328.2&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;DDX11L1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;processed_transcript&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;DDX11L1-002&quot;</span><span class="p">;</span> exon_number 1<span class="p">;</span>  exon_id <span class="s2">&quot;ENSE00002234944.1&quot;</span><span class="p">;</span>  level 2<span class="p">;</span> tag <span class="s2">&quot;basic&quot;</span><span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000000961.2&quot;</span><span class="p">;</span> havana_transcript <span class="s2">&quot;OTTHUMT00000362751.1&quot;</span><span class="p">;</span>
</code></pre></div>
<p>After calling <code>less</code>, you can move up, down, left and right by using the arrow keys. Type <code>shift g</code> to go to the end of the file, and <code>gg</code> to get back. Type <code>q</code> when you&rsquo;re done looking around.</p>

<p>The transcriptome has 9 columns. The first 8 are separated by tabs and look reasonable (chromosome, annotation source, feature type, start, end, score, strand, and phase), the last one is kind of hairy: it is made up of key-value pairs separated by semicolons, some fields are mandatory and others are optional, and the values are surrounded in double quotes. That&rsquo;s no way to live a decent life.</p>

<h2>Ask a question</h2>

<p>Imagine you wanted to get the list of all the protein-coding genes that only have one exon. How would you do it?</p>

<p>You could go learn Perl, or Python and write up a slow, 100-line-long script, but there is an easier way: use AWK. I <em>love</em> AWK. It is fast as a bullet, concise, and incredibly powerful. I couldn&rsquo;t live without it.</p>

<p>To use AWK, you need to understand three key ideas:</p>

<ol>
<li>AWK reads files <strong>one line at a time</strong></li>
<li>You can specify which lines should be read and which ones should be skipped by using a <strong>rule</strong></li>
<li>Once a line has been read, you can <strong>print text</strong> or <strong>do nothing</strong>.</li>
</ol>

<p>Let&rsquo;s try it with our example. Our first rule will make sure that column 3 is a gene:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk <span class="s1">&#39;$3 == &quot;gene&quot;&#39;</span> transcriptome.gtf <span class="p">|</span> head <span class="p">|</span> less -S

chr1    HAVANA  gene    <span class="m">11869</span>   <span class="m">14412</span>   .   +   .   gene_id <span class="s2">&quot;ENSG00000223972.4&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000223972.4&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;DDX11L1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;DDX11L1&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000000961.2&quot;</span><span class="p">;</span>
chr1    HAVANA  gene    <span class="m">14363</span>   <span class="m">29806</span>   .   -   .   gene_id <span class="s2">&quot;ENSG00000227232.4&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000227232.4&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;WASH7P&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;WASH7P&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000000958.1&quot;</span><span class="p">;</span>
chr1    HAVANA  gene    <span class="m">29554</span>   <span class="m">31109</span>   .   +   .   gene_id <span class="s2">&quot;ENSG00000243485.2&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000243485.2&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;MIR1302-11&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;MIR1302-11&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000000959.2&quot;</span><span class="p">;</span>
chr1    HAVANA  gene    <span class="m">34554</span>   <span class="m">36081</span>   .   -   .   gene_id <span class="s2">&quot;ENSG00000237613.2&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000237613.2&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;FAM138A&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;FAM138A&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000000960.1&quot;</span><span class="p">;</span>
chr1    HAVANA  gene    <span class="m">52473</span>   <span class="m">54936</span>   .   +   .   gene_id <span class="s2">&quot;ENSG00000268020.2&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000268020.2&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;OR4G4P&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;OR4G4P&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000185779.1&quot;</span><span class="p">;</span>
chr1    HAVANA  gene    <span class="m">62948</span>   <span class="m">63887</span>   .   +   .   gene_id <span class="s2">&quot;ENSG00000240361.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000240361.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;OR4G11P&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;OR4G11P&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000001095.2&quot;</span><span class="p">;</span>
chr1    HAVANA  gene    <span class="m">69091</span>   <span class="m">70008</span>   .   +   .   gene_id <span class="s2">&quot;ENSG00000186092.4&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000186092.4&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;OR4F5&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;OR4F5&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000001094.1&quot;</span><span class="p">;</span>
chr1    HAVANA  gene    <span class="m">89295</span>   <span class="m">133566</span>  .   -   .   gene_id <span class="s2">&quot;ENSG00000238009.2&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000238009.2&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;RP11-34P13.7&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;RP11-34P13.7&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000001096.2&quot;</span><span class="p">;</span>
chr1    HAVANA  gene    <span class="m">89551</span>   <span class="m">91105</span>   .   -   .   gene_id <span class="s2">&quot;ENSG00000239945.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000239945.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;RP11-34P13.8&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;RP11-34P13.8&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000001097.2&quot;</span><span class="p">;</span>
chr1    HAVANA  gene    <span class="m">131025</span>  <span class="m">134836</span>  .   +   .   gene_id <span class="s2">&quot;ENSG00000233750.3&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000233750.3&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;CICP27&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;CICP27&quot;</span><span class="p">;</span> level 1<span class="p">;</span> tag <span class="s2">&quot;pseudo_consens&quot;</span><span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000001257.3&quot;</span><span class="p">;</span>
</code></pre></div>
<p>Rules go between single quotes. Numbers after the dollar sign specify a column, so <code>$3</code> refers to column 3. The only exception is <code>$0</code>, which specifies the entire line.</p>

<p>The double equals sign <code>==</code> is how computer people write equality, it drives the math people crazy.</p>

<p>Character strings, like the word &ldquo;gene&rdquo;, must be surrounded by double quotes.</p>

<p>The vertical line <code>|</code> is called a pipe. It connects the command on the left of the pipe with the command on the right. This tells the output generated by the command at the left to become the input of the command on the right.</p>

<p>Now that we have used column 3 to filter, we don&rsquo;t really care about any of the information in columns 1 through 8, so we can get rid of it by only printing column 9.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk <span class="s1">&#39;$3 == &quot;gene&quot; { print $9 }&#39;</span> transcriptome.gtf <span class="p">|</span> head <span class="p">|</span> less -S

gene_id
gene_id
gene_id
gene_id
gene_id
gene_id
gene_id
gene_id
gene_id
gene_id
</code></pre></div>
<p>It worked, sort of. We used the stuff that comes before the braces to select the lines that we care about, and the stuff that goes inside the braces <code>{ }</code> to tell AWK what we want it to do with that line—in this case, print column 9—, but only <code>gene_id</code> showed up. What happened to the rest?</p>

<h2>What is a column?</h2>

<p>By default, AWK uses whitespace as the delimiter between columns but there are two types of whitespace: spaces and tabs. Check this out:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s2">&quot;a b c&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;{ print $2 }&#39;</span>

<span class="nb">echo</span> <span class="s2">&quot;a\tb\tc&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;{ print $2 }&#39;</span>
</code></pre></div>
<p>Both commands return a <code>b</code>. We are using <code>echo</code> to send AWK a line of text (instead of reading from a file), and telling AWK to print the second column. In the second example we are separating the columns by tabs (<code>\t</code> is the special character for tabs) instead of spaces. We can tell AWK to treat spaces and tabs differently by using the <code>-F</code> option followed by a space and a character in double quotes.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s2">&quot;a,b,c&quot;</span> <span class="p">|</span> awk -F <span class="s2">&quot;,&quot;</span> <span class="s1">&#39;{ print $2 }&#39;</span> <span class="c"># separate by commas, returns b</span>

<span class="nb">echo</span> <span class="s2">&quot;a b c&quot;</span> <span class="p">|</span> awk -F <span class="s2">&quot;\t&quot;</span> <span class="s1">&#39;{ print $2 }&#39;</span> <span class="c"># separate by tabs, returns nothing</span>

<span class="nb">echo</span> <span class="s2">&quot;a\tb\tc&quot;</span> <span class="p">|</span> awk -F <span class="s2">&quot;\t&quot;</span> <span class="s1">&#39;{ print $2 }&#39;</span> <span class="c"># separate by tabs, returns b</span>
</code></pre></div>
<p>It&rsquo;s not very intuitive that <code>-F</code> would define what the separator should be, and everybody forgets when they start learning AWK. Luckily, it&rsquo;s easy to find help.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">man awk
</code></pre></div>
<p>This takes you to the Unix manual page on AWK, which behaves in a similar way as <code>less</code>. You can use the arrows to move around and you can search for words using the slash <code>/</code> followed by whatever you are looking for. Type <code>/-F</code> and press <code>Enter</code>. The screen will advance to the usage line:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk <span class="o">[</span> -F fs <span class="o">]</span> <span class="o">[</span> -v <span class="nv">var</span><span class="o">=</span>value <span class="o">]</span> <span class="o">[</span> <span class="s1">&#39;prog&#39;</span> <span class="p">|</span> -f progfile <span class="o">]</span> <span class="o">[</span> file ...  <span class="o">]</span>
</code></pre></div>
<p>which contains <code>-F</code>, to move to the next occurrence, press <code>n</code>:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">The -F fs option defines the input field separator to be the regular expression fs.
</code></pre></div>
<p>Bingo. You can go back to the previous occurrence by pressing <code>shift n</code>. Press <code>q</code> to leave.</p>

<p>AWK didn&rsquo;t return anything back in the <code>echo &quot;a b c&quot;</code> example, why? Because it didn&rsquo;t find any tabs, so it only saw one column, which means that there was no second column to print. See for yourself:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s2">&quot;a b c&quot;</span> <span class="p">|</span> awk -F <span class="s2">&quot;\t&quot;</span> <span class="s1">&#39;{ print $1 }&#39;</span> <span class="c"># a b c</span>
</code></pre></div>
<p>Back to the genes.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">awk -F <span class="s2">&quot;\t&quot;</span> <span class="s1">&#39;$3 == &quot;gene&quot; { print $9 }&#39;</span> transcriptome.gtf <span class="p">|</span> head <span class="p">|</span> less -S

gene_id <span class="s2">&quot;ENSG00000223972.4&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000223972.4&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;DDX11L1&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;DDX11L1&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000000961.2&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000227232.4&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000227232.4&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;WASH7P&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;WASH7P&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000000958.1&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000243485.2&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000243485.2&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;MIR1302-11&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;MIR1302-11&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000000959.2&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000237613.2&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000237613.2&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;FAM138A&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;FAM138A&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000000960.1&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000268020.2&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000268020.2&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;OR4G4P&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;OR4G4P&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000185779.1&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000240361.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000240361.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;OR4G11P&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;OR4G11P&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000001095.2&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000186092.4&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000186092.4&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;OR4F5&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;protein_coding&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;OR4F5&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000001094.1&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000238009.2&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000238009.2&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;RP11-34P13.7&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;RP11-34P13.7&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000001096.2&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000239945.1&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000239945.1&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;RP11-34P13.8&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;lincRNA&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;NOVEL&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;RP11-34P13.8&quot;</span><span class="p">;</span> level 2<span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000001097.2&quot;</span><span class="p">;</span>
gene_id <span class="s2">&quot;ENSG00000233750.3&quot;</span><span class="p">;</span> transcript_id <span class="s2">&quot;ENSG00000233750.3&quot;</span><span class="p">;</span> gene_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> gene_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> gene_name <span class="s2">&quot;CICP27&quot;</span><span class="p">;</span> transcript_type <span class="s2">&quot;pseudogene&quot;</span><span class="p">;</span> transcript_status <span class="s2">&quot;KNOWN&quot;</span><span class="p">;</span> transcript_name <span class="s2">&quot;CICP27&quot;</span><span class="p">;</span> level 1<span class="p">;</span> tag <span class="s2">&quot;pseudo_consens&quot;</span><span class="p">;</span> havana_gene <span class="s2">&quot;OTTHUMG00000001257.3&quot;</span><span class="p">;</span>
</code></pre></div>
<p>Now we have all the genes, but how do we filter for protein-coding genes? The answer, in <a href="http://reasoniamhere.com/2013/09/17/awk-gtf-how-to-analyze-a-transcriptome-like-a-pro-part-2">Part 2</a>.</p>

        ]]></description>
      </item>
    
  </channel>
</rss>